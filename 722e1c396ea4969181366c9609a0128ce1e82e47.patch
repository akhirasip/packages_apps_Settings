From 722e1c396ea4969181366c9609a0128ce1e82e47 Mon Sep 17 00:00:00 2001
From: XXMrHyde <xxmrhyde@gmx.co.uk>
Date: Fri, 22 May 2015 11:29:51 -0600
Subject: [PATCH] Add Color picker from XXMrHyde

Change-Id: I3b2e97dd8ca81fcd2bc1e7a38c524b200cf8075d
---
 res/layout/dialog_color_picker.xml                 | 286 ++++++
 res/values/bliss_strings.xml                       |  13 +
 .../colorpicker/AlphaPatternDrawable.java          | 128 +++
 .../preference/colorpicker/ColorPickerDialog.java  | 445 ++++++++++
 .../colorpicker/ColorPickerPanelView.java          | 172 ++++
 .../colorpicker/ColorPickerPreference.java         | 286 ++++++
 .../preference/colorpicker/ColorPickerView.java    | 954 +++++++++++++++++++++
 7 files changed, 2284 insertions(+)
 create mode 100644 res/layout/dialog_color_picker.xml
 create mode 100644 src/net/margaritov/preference/colorpicker/AlphaPatternDrawable.java
 create mode 100644 src/net/margaritov/preference/colorpicker/ColorPickerDialog.java
 create mode 100644 src/net/margaritov/preference/colorpicker/ColorPickerPanelView.java
 create mode 100644 src/net/margaritov/preference/colorpicker/ColorPickerPreference.java
 create mode 100644 src/net/margaritov/preference/colorpicker/ColorPickerView.java

diff --git a/res/layout/dialog_color_picker.xml b/res/layout/dialog_color_picker.xml
new file mode 100644
index 0000000..2bf13f9
--- /dev/null
+++ b/res/layout/dialog_color_picker.xml
@@ -0,0 +1,286 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- 
+     Copyright (C) 2010 Daniel Nilsson
+     Copyright (C) 2013 Slimroms
+     Copyright (C) 2015 DarkKat
+
+     Licensed under the Apache License, Version 2.0 (the "License"); 
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@*android:color/dark_material_dialog_background"
+    android:orientation="vertical">
+
+    <RelativeLayout
+        android:layout_width="match_parent"
+        android:layout_height="56dp">
+
+        <LinearLayout
+            android:id="@+id/action_bar_main"
+            android:layout_width="match_parent"
+            android:layout_height="56dp"
+            android:layout_alignParentStart="true"
+            android:paddingRight="4dp"
+            android:gravity="center_vertical"
+            android:background="@color/theme_primary"
+            android:orientation="horizontal">
+
+            <ImageButton
+                android:id="@+id/back"
+                android:layout_width="48dp"
+                android:layout_height="48dp"
+                android:layout_marginLeft="4dp"
+                android:src="@drawable/ic_ab_back_material"
+                android:background="@drawable/item_background_borderless_material"
+                android:scaleType="centerInside" />
+
+            <TextView
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_marginLeft="8dp"
+                android:textSize="20sp"
+                android:textColor="@color/white"
+                android:text="@string/dialog_color_picker_title"
+                android:singleLine="true"
+                android:ellipsize="end" />
+
+            <View
+                android:layout_width="0dp"
+                android:layout_height="0dp"
+                android:layout_weight="1" />
+
+            <ImageButton
+                android:id="@+id/edit_hex"
+                android:layout_width="48dp"
+                android:layout_height="48dp"
+                android:src="@drawable/ic_action_edit"
+                android:background="@drawable/item_background_borderless_material"
+                android:scaleType="centerInside" />
+
+            <ImageButton
+                android:id="@+id/palette"
+                android:layout_width="48dp"
+                android:layout_height="48dp"
+                android:src="@drawable/ic_action_palette"
+                android:background="@drawable/item_background_borderless_material"
+                android:scaleType="centerInside" />
+
+            <ImageButton
+                android:id="@+id/reset"
+                android:layout_width="48dp"
+                android:layout_height="48dp"
+                android:src="@drawable/ic_action_reset"
+                android:background="@drawable/item_background_borderless_material"
+                android:scaleType="centerInside" />
+
+        </LinearLayout>
+
+        <LinearLayout
+            android:id="@+id/action_bar_edit_hex"
+            android:layout_width="match_parent"
+            android:layout_height="56dp"
+            android:layout_alignParentStart="true"
+            android:gravity="center_vertical"
+            android:orientation="horizontal">
+
+            <ImageButton
+                android:id="@+id/action_bar_edit_hex_back"
+                android:layout_width="48dp"
+                android:layout_height="48dp"
+                android:layout_marginLeft="4dp"
+                android:src="@drawable/ic_ab_back_material"
+                android:background="@drawable/item_background_borderless_material"
+                android:scaleType="centerInside" />
+
+            <TextView
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_marginLeft="8dp"
+                android:layout_marginRight="8dp"
+                android:textSize="20sp"
+                android:textColor="@color/white"
+                android:text="@string/hex" />
+
+            <EditText
+                android:id="@+id/hex"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:textSize="16sp"
+                android:hint="@string/hex_hint" />
+
+            <View
+                android:layout_width="0dp"
+                android:layout_height="0dp"
+                android:layout_weight="1" />
+
+            <ImageButton
+                android:id="@+id/enter"
+                android:layout_width="48dp"
+                android:layout_height="48dp"
+                android:layout_marginRight="4dp"
+                android:src="@drawable/ic_action_set"
+                android:background="@drawable/item_background_borderless_material"
+                android:scaleType="centerInside" />
+
+        </LinearLayout>
+
+        <View
+            android:id="@+id/divider"
+            android:layout_width="match_parent"
+            android:layout_height="1dp"
+            android:layout_alignParentBottom="true"
+            android:layout_alignParentLeft="true"
+            android:background="@color/divider" />
+
+    </RelativeLayout>
+
+    <net.margaritov.preference.colorpicker.ColorPickerView
+        android:id="@+id/color_picker_view"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="8.5dp"
+        android:layout_marginLeft="8.5dp"
+        android:layout_marginRight="8.5dp"
+        android:layout_centerHorizontal="true"
+        android:tag="portrait" />
+
+    <LinearLayout
+        android:layout_width="wrap_content"
+        android:layout_height="36dp"
+        android:layout_marginTop="8.5dp"
+        android:layout_marginBottom="8dp"
+        android:layout_marginLeft="12dp"
+        android:layout_marginRight="12dp"
+        android:orientation="horizontal">
+
+        <net.margaritov.preference.colorpicker.ColorPickerPanelView
+            android:id="@+id/panel_view_1"
+            android:layout_width="0px"
+            android:layout_height="wrap_content"
+            android:layout_marginLeft="4dp"
+            android:layout_marginRight="4dp"
+            android:layout_weight="0.5" />
+
+        <net.margaritov.preference.colorpicker.ColorPickerPanelView
+            android:id="@+id/panel_view_2"
+            android:layout_width="0px"
+            android:layout_height="wrap_content"
+            android:layout_marginLeft="4dp"
+            android:layout_marginRight="4dp"
+            android:layout_weight="0.5" />
+
+        <net.margaritov.preference.colorpicker.ColorPickerPanelView
+            android:id="@+id/panel_view_3"
+            android:layout_width="0px"
+            android:layout_height="wrap_content"
+            android:layout_marginLeft="4dp"
+            android:layout_marginRight="4dp"
+            android:layout_weight="0.5" />
+
+        <net.margaritov.preference.colorpicker.ColorPickerPanelView
+            android:id="@+id/panel_view_4"
+            android:layout_width="0px"
+            android:layout_height="wrap_content"
+            android:layout_marginLeft="4dp"
+            android:layout_marginRight="4dp"
+            android:layout_weight="0.5" />
+
+    </LinearLayout>
+
+    <LinearLayout
+        android:layout_width="wrap_content"
+        android:layout_height="36dp"
+        android:layout_marginBottom="8dp"
+        android:layout_marginLeft="12dp"
+        android:layout_marginRight="12dp"
+        android:orientation="horizontal">
+
+        <net.margaritov.preference.colorpicker.ColorPickerPanelView
+            android:id="@+id/panel_view_5"
+            android:layout_width="0px"
+            android:layout_height="wrap_content"
+            android:layout_marginLeft="4dp"
+            android:layout_marginRight="4dp"
+            android:layout_weight="0.5" />
+
+        <net.margaritov.preference.colorpicker.ColorPickerPanelView
+            android:id="@+id/panel_view_6"
+            android:layout_width="0px"
+            android:layout_height="wrap_content"
+            android:layout_marginLeft="4dp"
+            android:layout_marginRight="4dp"
+            android:layout_weight="0.5" />
+
+        <net.margaritov.preference.colorpicker.ColorPickerPanelView
+            android:id="@+id/panel_view_7"
+            android:layout_width="0px"
+            android:layout_height="wrap_content"
+            android:layout_marginLeft="4dp"
+            android:layout_marginRight="4dp"
+            android:layout_weight="0.5" />
+
+        <net.margaritov.preference.colorpicker.ColorPickerPanelView
+            android:id="@+id/panel_view_8"
+            android:layout_width="0px"
+            android:layout_height="wrap_content"
+            android:layout_marginLeft="4dp"
+            android:layout_marginRight="4dp"
+            android:layout_weight="0.5" />
+
+    </LinearLayout>
+
+    <TextView
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="8dp"
+        android:layout_marginBottom="8dp"
+        android:layout_marginLeft="16dp"
+        android:layout_marginRight="16dp"
+        android:gravity="center"
+        android:text="@string/press_color_to_apply"
+        android:textAppearance="?android:attr/textAppearanceSmall" />
+
+    <LinearLayout
+        android:layout_width="wrap_content"
+        android:layout_height="36dp"
+        android:layout_marginBottom="8dp"
+        android:layout_marginLeft="16dp"
+        android:layout_marginRight="16dp"
+        android:orientation="horizontal">
+
+        <net.margaritov.preference.colorpicker.ColorPickerPanelView
+            android:id="@+id/old_color_panel"
+            android:layout_width="0px"
+            android:layout_height="match_parent"
+            android:layout_weight="0.5" />
+
+        <TextView
+            android:layout_width="wrap_content"
+            android:layout_height="match_parent"
+            android:layout_marginLeft="8dp"
+            android:layout_marginRight="8dp"
+            android:gravity="center"
+            android:textSize="20sp"
+            android:text="@string/arrow_right" />
+
+        <net.margaritov.preference.colorpicker.ColorPickerPanelView
+            android:id="@+id/new_color_panel"
+            android:layout_width="0px"
+            android:layout_height="match_parent"
+            android:layout_weight="0.5" />
+
+    </LinearLayout>
+</LinearLayout>
diff --git a/src/net/margaritov/preference/colorpicker/AlphaPatternDrawable.java b/src/net/margaritov/preference/colorpicker/AlphaPatternDrawable.java
new file mode 100644
index 0000000..07736be
--- /dev/null
+++ b/src/net/margaritov/preference/colorpicker/AlphaPatternDrawable.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2010 Daniel Nilsson
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.margaritov.preference.colorpicker;
+
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.graphics.Canvas;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+
+/**
+ * This drawable that draws a simple white and gray chessboard pattern.
+ * It's pattern you will often see as a background behind a
+ * partly transparent image in many applications.
+ * @author Daniel Nilsson
+ */
+public class AlphaPatternDrawable extends Drawable {
+
+    private int mRectangleSize = 10;
+
+    private Paint mPaint = new Paint();
+    private Paint mPaintWhite = new Paint();
+    private Paint mPaintGray = new Paint();
+
+    private int numRectanglesHorizontal;
+    private int numRectanglesVertical;
+
+    /**
+     * Bitmap in which the pattern will be cahched.
+     */
+    private Bitmap        mBitmap;
+
+    public AlphaPatternDrawable(int rectangleSize) {
+        mRectangleSize = rectangleSize;
+        mPaintWhite.setColor(0xffffffff);
+        mPaintGray.setColor(0xffcbcbcb);
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        canvas.drawBitmap(mBitmap, null, getBounds(), mPaint);
+    }
+
+    @Override
+    public int getOpacity() {
+        return 0;
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+        throw new UnsupportedOperationException("Alpha is not supported by this drawwable.");
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter cf) {
+        throw new UnsupportedOperationException("ColorFilter is not supported by this drawwable.");
+    }
+
+    @Override
+    protected void onBoundsChange(Rect bounds) {
+        super.onBoundsChange(bounds);
+
+        int height = bounds.height();
+        int width = bounds.width();
+
+        numRectanglesHorizontal = (int) Math.ceil((width / mRectangleSize));
+        numRectanglesVertical = (int) Math.ceil(height / mRectangleSize);
+
+        generatePatternBitmap();
+
+    }
+
+    /**
+     * This will generate a bitmap with the pattern
+     * as big as the rectangle we were allow to draw on.
+     * We do this to chache the bitmap so we don't need to
+     * recreate it each time draw() is called since it
+     * takes a few milliseconds.
+     */
+    private void generatePatternBitmap(){
+
+        if(getBounds().width() <= 0 || getBounds().height() <= 0){
+            return;
+        }
+
+        mBitmap = Bitmap.createBitmap(getBounds().width(), getBounds().height(), Config.ARGB_8888);
+        Canvas canvas = new Canvas(mBitmap);
+
+        Rect r = new Rect();
+        boolean verticalStartWhite = true;
+        for (int i = 0; i <= numRectanglesVertical; i++) {
+
+            boolean isWhite = verticalStartWhite;
+            for (int j = 0; j <= numRectanglesHorizontal; j++) {
+
+                r.top = i * mRectangleSize;
+                r.left = j * mRectangleSize;
+                r.bottom = r.top + mRectangleSize;
+                r.right = r.left + mRectangleSize;
+
+                canvas.drawRect(r, isWhite ? mPaintWhite : mPaintGray);
+
+                isWhite = !isWhite;
+            }
+
+            verticalStartWhite = !verticalStartWhite;
+
+        }
+
+    }
+
+}
diff --git a/src/net/margaritov/preference/colorpicker/ColorPickerDialog.java b/src/net/margaritov/preference/colorpicker/ColorPickerDialog.java
new file mode 100644
index 0000000..db85eb4
--- /dev/null
+++ b/src/net/margaritov/preference/colorpicker/ColorPickerDialog.java
@@ -0,0 +1,445 @@
+/*
+ * Copyright (C) 2010 Daniel Nilsson
+ * Copyright (C) 2013 Slimroms
+ * Copyright (C) 2015 DarkKat
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.margaritov.preference.colorpicker;
+
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.animation.ValueAnimator;
+import android.app.Dialog;
+import android.content.Context;
+import android.graphics.Color;
+import android.graphics.PixelFormat;
+import android.os.Bundle;
+import android.support.v4.view.ViewCompat;
+import android.view.LayoutInflater;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewGroup.LayoutParams;
+import android.view.ViewTreeObserver;
+import android.view.Window;
+import android.widget.EditText;
+import android.widget.ImageButton;
+import android.widget.LinearLayout;
+import android.widget.PopupMenu;
+
+import com.android.settings.R;
+
+public class ColorPickerDialog extends Dialog implements
+        ColorPickerView.OnColorChangedListener,
+        PopupMenu.OnMenuItemClickListener,
+        View.OnClickListener {
+
+    private View mColorPickerView;
+    private LinearLayout mActionBarMain;
+    private LinearLayout mActionBarEditHex;
+
+    private ImageButton mBackButton;
+    private ImageButton mEditHexButton;
+    private ImageButton mPaletteButton;
+    private ImageButton mResetButton;
+
+    private ImageButton mHexBackButton;
+    private EditText mHex;
+    private ImageButton mSetButton;
+    private View mDivider;
+
+    private ColorPickerView mColorPicker;
+    private ColorPickerPanelView[] mPanelViewButtons;
+    private ColorPickerPanelView mOldColor;
+    private ColorPickerPanelView mNewColor;
+
+    private Animator mEditHexBarFadeInAnimator;
+    private Animator mEditHexBarFadeOutAnimator;
+    private boolean mHideEditHexBar = false;
+
+    private Animator mColorTransitionAnimator;
+    private boolean mAnimateColorTransition = true;
+    private boolean mIsPanelButtons = true;
+
+    private final int mInitialColor;
+    private final int mAndroidColor;
+    private final int mBlissColor;
+    private int mNewColorValue;
+    private boolean mIsResetButtonEnabled = false;
+
+    private static final int PALETTE_BLISS  = 0;
+    private static final int PALETTE_MATERIAL = 1;
+    private static final int PALETTE_RGB      = 2;
+    private int mPalette = PALETTE_BLISS;
+
+    private static final int[][] mPaletteColors = {
+            { Color.BLACK, 0xff1b1f23, 0xff33b5e5, 0xff009688,
+              Color.WHITE, 0xff3f51b5, 0xfff44336, 0xff9c27b0 },
+            { 0xfff44336, 0xff4caf50, 0xff2196f3, 0xff009688,
+              0xff3f51b5, 0xff9c27b0, 0xffffeb3b, 0xffff9800 },
+            { Color.BLACK, Color.RED, Color.GREEN, Color.BLUE,
+              Color.WHITE, 0xff800080, Color.YELLOW, 0xffffa500 }
+        };
+
+    private OnColorChangedListener mListener;
+
+    public interface OnColorChangedListener {
+        public void onColorChanged(int color);
+    }
+
+    public ColorPickerDialog(Context context, int theme, int initialColor,
+            int androidColor, int blissColor) {
+        super(context, theme);
+        mInitialColor = initialColor;
+        mAndroidColor = androidColor;
+        mBlissColor = blissColor;
+        if (mAndroidColor != 0x00000000 && mBlissColor != 0x00000000) {
+            mIsResetButtonEnabled = true;
+        }
+
+        setUp();
+    }
+
+    private void setUp() {
+        // To fight color branding.
+        getWindow().setFormat(PixelFormat.RGBA_8888);
+        getWindow().setLayout(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
+        requestWindowFeature(Window.FEATURE_NO_TITLE);
+
+        LayoutInflater inflater = (LayoutInflater) getContext().getSystemService(
+                Context.LAYOUT_INFLATER_SERVICE);
+
+        mColorPickerView = inflater.inflate(R.layout.dialog_color_picker, null);
+
+        setContentView(mColorPickerView);
+
+        mActionBarMain = (LinearLayout) mColorPickerView.findViewById(R.id.action_bar_main);
+
+        mActionBarEditHex = (LinearLayout) mColorPickerView.findViewById(R.id.action_bar_edit_hex);
+        mActionBarEditHex.setVisibility(View.GONE);
+
+        mDivider = mColorPickerView.findViewById(R.id.divider);
+        mDivider.setVisibility(View.GONE);
+
+        mBackButton = (ImageButton) mColorPickerView.findViewById(R.id.back);
+        mBackButton.setOnClickListener(this);
+
+        mEditHexButton = (ImageButton) mColorPickerView.findViewById(R.id.edit_hex);
+        mEditHexButton.setOnClickListener(this);
+
+        mPaletteButton = (ImageButton) mColorPickerView.findViewById(R.id.palette);
+        mPaletteButton.setOnClickListener(this);
+
+        mResetButton = (ImageButton) mColorPickerView.findViewById(R.id.reset);
+        if (mIsResetButtonEnabled) {
+            mResetButton.setOnClickListener(this);
+        } else {
+            mResetButton.setVisibility(View.GONE);
+        }
+
+        mHexBackButton = (ImageButton) mColorPickerView.findViewById(R.id.action_bar_edit_hex_back);
+        mHexBackButton.setOnClickListener(this);
+
+        mHex = (EditText) mColorPickerView.findViewById(R.id.hex);
+        mHex.setText(ColorPickerPreference.convertToARGB(mInitialColor));
+
+        mSetButton = (ImageButton) mColorPickerView.findViewById(R.id.enter);
+        mSetButton.setOnClickListener(this);
+
+        mColorPicker = (ColorPickerView) mColorPickerView.findViewById(R.id.color_picker_view);
+        mColorPicker.setOnColorChangedListener(this);
+
+        mPanelViewButtons = new ColorPickerPanelView[8];
+        mPanelViewButtons[0] = (ColorPickerPanelView) mColorPickerView.findViewById(R.id.panel_view_1);
+        mPanelViewButtons[1] = (ColorPickerPanelView) mColorPickerView.findViewById(R.id.panel_view_2);
+        mPanelViewButtons[2] = (ColorPickerPanelView) mColorPickerView.findViewById(R.id.panel_view_3);
+        mPanelViewButtons[3] = (ColorPickerPanelView) mColorPickerView.findViewById(R.id.panel_view_4);
+        mPanelViewButtons[4] = (ColorPickerPanelView) mColorPickerView.findViewById(R.id.panel_view_5);
+        mPanelViewButtons[5] = (ColorPickerPanelView) mColorPickerView.findViewById(R.id.panel_view_6);
+        mPanelViewButtons[6] = (ColorPickerPanelView) mColorPickerView.findViewById(R.id.panel_view_7);
+        mPanelViewButtons[7] = (ColorPickerPanelView) mColorPickerView.findViewById(R.id.panel_view_8);
+
+        for (int i=0; i<mPanelViewButtons.length; i++) {
+            mPanelViewButtons[i].setOnClickListener(this);
+        }
+
+        mOldColor = (ColorPickerPanelView) mColorPickerView.findViewById(R.id.old_color_panel);
+        mOldColor.setOnClickListener(this);
+
+        mNewColor = (ColorPickerPanelView) mColorPickerView.findViewById(R.id.new_color_panel);
+        mNewColor.setOnClickListener(this);
+
+        mNewColorValue = mInitialColor;
+        mOldColor.setColor(mInitialColor);
+
+        setPanelViewButtonsColor();
+        setupAnimators();
+
+        mAnimateColorTransition = false;
+        mColorPicker.setColor(mInitialColor, true);
+    }
+
+    public void setAlphaSliderVisible(boolean visible) {
+        mColorPicker.setAlphaSliderVisible(visible);
+    }
+
+    private void setPanelViewButtonsColor() {
+        for (int i=0; i<mPanelViewButtons.length; i++) {
+            mPanelViewButtons[i].setColor(mPaletteColors[mPalette][i]);
+        }
+    }
+
+    /**
+     * Set a OnColorChangedListener to get notified when the color selected by the user has changed.
+     *
+     * @param listener
+     */
+    public void setOnColorChangedListener(OnColorChangedListener listener) {
+        mListener = listener;
+    }
+
+    @Override
+    public void onColorChanged(int color) {
+        mNewColorValue = color;
+        if (mAnimateColorTransition == false) {
+            mAnimateColorTransition = true;
+            mNewColor.setColor(mNewColorValue);
+        } else {
+            mIsPanelButtons = false;
+            mColorTransitionAnimator.start();
+        }
+        try {
+            if (mHex != null) {
+                mHex.setText(ColorPickerPreference.convertToARGB(color));
+            }
+        } catch (Exception e) {
+
+        }
+    }
+
+    private int getColor() {
+        return mColorPicker.getColor();
+    }
+
+    @Override
+    public void onClick(View v) {
+        if (v.getId() == R.id.back ||
+                v.getId() == R.id.old_color_panel ||
+                v.getId() == R.id.new_color_panel) {
+            if (mListener != null && v.getId() == R.id.new_color_panel) {
+                mListener.onColorChanged(mNewColor.getColor());
+            }
+            dismiss();
+        } else if (v.getId() == R.id.palette) {
+            showPalettePopupMenu(v);
+        } else if (v.getId() == R.id.edit_hex) {
+            showActionBarEditHex();
+        } else if (v.getId() == R.id.reset) {
+            showResetPopupMenu(v);
+        } else if (v.getId() == R.id.action_bar_edit_hex_back) {
+            hideActionBarEditHex();
+        } else if (v.getId() == R.id.enter) {
+            String text = mHex.getText().toString();
+            try {
+                int newColor = ColorPickerPreference.convertToColorInt(text);
+                mColorPicker.setColor(newColor, true);
+            } catch (Exception e) {
+            }
+            hideActionBarEditHex();
+        } else {
+            for (int i=0; i<mPanelViewButtons.length; i++) {
+                int panelViewButtonId = mPanelViewButtons[i].getId();
+                if (v.getId() == panelViewButtonId) {
+                    try {
+                        mColorPicker.setColor(mPaletteColors[mPalette][i], true);
+                    } catch (Exception e) {
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    public boolean onMenuItemClick(MenuItem item) {
+        if (item.getItemId() == R.id.palette_bliss) {
+            mPalette = PALETTE_BLISS;
+            mColorTransitionAnimator.start();
+            return true;
+        } else if (item.getItemId() == R.id.palette_material) {
+            mPalette = PALETTE_MATERIAL;
+            mColorTransitionAnimator.start();
+            return true;
+        } else if (item.getItemId() == R.id.palette_rgb) {
+            mPalette = PALETTE_RGB;
+            mColorTransitionAnimator.start();
+            return true;
+        } else if (item.getItemId() == R.id.reset_android) {
+            mColorPicker.setColor(mAndroidColor, true);
+            return true;
+        } else if (item.getItemId() == R.id.reset_bliss) {
+            mColorPicker.setColor(mBlissColor, true);
+            return true;
+        }
+        return false;
+    }
+
+    private void showPalettePopupMenu(View v) {
+        PopupMenu popup = new PopupMenu(getContext(), v);
+        popup.setOnMenuItemClickListener(this);
+        popup.inflate(R.menu.palette);
+        popup.show();
+    }
+
+    private void showResetPopupMenu(View v) {
+        PopupMenu popup = new PopupMenu(getContext(), v);
+        popup.setOnMenuItemClickListener(this);
+        popup.inflate(R.menu.reset);
+        popup.show();
+    }
+
+    private void showActionBarEditHex() {
+        mEditHexBarFadeInAnimator.start();
+    }
+
+    private void hideActionBarEditHex() {
+        mEditHexBarFadeOutAnimator.start();
+    }
+
+    private void setupAnimators() {
+        mColorPickerView.getViewTreeObserver().addOnPreDrawListener(
+                new ViewTreeObserver.OnPreDrawListener() {
+            @Override
+            public boolean onPreDraw() {
+                mColorPickerView.getViewTreeObserver().removeOnPreDrawListener(this);
+                mHideEditHexBar = false;
+                mEditHexBarFadeInAnimator = createAlphaAnimator(0, 100);
+                mHideEditHexBar = true;
+                mEditHexBarFadeOutAnimator = createAlphaAnimator(100, 0);
+                return true;
+            }
+        });
+        mColorTransitionAnimator = createColorTransitionAnimator(0, 1);
+    }
+
+    private ValueAnimator createAlphaAnimator(int start, int end) {
+        ValueAnimator animator = ValueAnimator.ofInt(start, end);
+
+        animator.setDuration(500);
+        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+            @Override
+            public void onAnimationUpdate(ValueAnimator valueAnimator) {
+                int value = (Integer) valueAnimator.getAnimatedValue();
+                float currentAlpha = value / 100f;
+                mActionBarMain.setAlpha(1f - currentAlpha);
+                mActionBarEditHex.setAlpha(currentAlpha);
+                mDivider.setAlpha(currentAlpha);
+            }
+        });
+        if (mHideEditHexBar) {
+            animator.addListener(new AnimatorListenerAdapter() {
+                @Override
+                public void onAnimationStart(Animator animation) {
+                    mActionBarMain.setVisibility(View.VISIBLE);
+                    ViewCompat.jumpDrawablesToCurrentState(mActionBarMain);
+                }
+            });
+            animator.addListener(new AnimatorListenerAdapter() {
+                @Override
+                public void onAnimationEnd(Animator animation) {
+                    mActionBarEditHex.setVisibility(View.GONE);
+                    mDivider.setVisibility(View.GONE);
+                }
+            });
+        } else {
+            animator.addListener(new AnimatorListenerAdapter() {
+                @Override
+                public void onAnimationStart(Animator animation) {
+                    mActionBarEditHex.setVisibility(View.VISIBLE);
+                    ViewCompat.jumpDrawablesToCurrentState(mActionBarEditHex);
+                    mDivider.setVisibility(View.VISIBLE);
+                }
+            });
+            animator.addListener(new AnimatorListenerAdapter() {
+                @Override
+                public void onAnimationEnd(Animator animation) {
+                    mActionBarMain.setVisibility(View.GONE);
+                }
+            });
+        }
+        return animator;
+    }
+
+    private ValueAnimator createColorTransitionAnimator(float start, float end) {
+        ValueAnimator animator = ValueAnimator.ofFloat(start, end);
+
+        animator.setDuration(500);
+        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
+            @Override public void onAnimationUpdate(ValueAnimator animation) {
+                float position = animation.getAnimatedFraction();
+                if (mIsPanelButtons) {
+                    int[] blended = new int[8];
+                    for (int i=0; i<mPanelViewButtons.length; i++) {
+                        blended[i] = blendColors(
+                                mPanelViewButtons[i].getColor(),
+                                mPaletteColors[mPalette][i],
+                                position);
+                        mPanelViewButtons[i].setColor(blended[i]);
+                    }
+                } else {
+                    int blended = blendColors(mNewColor.getColor(), mNewColorValue, position);
+                    mNewColor.setColor(blended);
+                }
+            }
+        });
+        animator.addListener(new AnimatorListenerAdapter() {
+                @Override
+                public void onAnimationEnd(Animator animation) {
+                    if (!mIsPanelButtons) {
+                        mIsPanelButtons = true;
+                    }
+                }
+            });
+        return animator;
+    }
+
+    private int blendColors(int from, int to, float ratio) {
+        final float inverseRatio = 1f - ratio;
+
+        final float a = Color.alpha(to) * ratio + Color.alpha(from) * inverseRatio;
+        final float r = Color.red(to) * ratio + Color.red(from) * inverseRatio;
+        final float g = Color.green(to) * ratio + Color.green(from) * inverseRatio;
+        final float b = Color.blue(to) * ratio + Color.blue(from) * inverseRatio;
+
+        return Color.argb((int) a, (int) r, (int) g, (int) b);
+    }
+
+    @Override
+    public Bundle onSaveInstanceState() {
+        Bundle state = super.onSaveInstanceState();
+        state.putInt("old_color", mOldColor.getColor());
+        state.putInt("new_color", mNewColor.getColor());
+        state.putInt("palette", mPalette);
+        return state;
+    }
+
+    @Override
+    public void onRestoreInstanceState(Bundle savedInstanceState) {
+        super.onRestoreInstanceState(savedInstanceState);
+        mOldColor.setColor(savedInstanceState.getInt("old_color"));
+        mColorPicker.setColor(savedInstanceState.getInt("new_color"), true);
+        mPalette = savedInstanceState.getInt("palette");
+    }
+}
diff --git a/src/net/margaritov/preference/colorpicker/ColorPickerPanelView.java b/src/net/margaritov/preference/colorpicker/ColorPickerPanelView.java
new file mode 100644
index 0000000..91a6d2f
--- /dev/null
+++ b/src/net/margaritov/preference/colorpicker/ColorPickerPanelView.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2010 Daniel Nilsson
+ * Copyright (C) 2013 Slimroms
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.margaritov.preference.colorpicker;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.RectF;
+import android.util.AttributeSet;
+import android.view.View;
+
+/**
+ * This class draws a panel which which will be filled with a color which can be set.
+ * It can be used to show the currently selected color which you will get from
+ * the {@link ColorPickerView}.
+ * @author Daniel Nilsson
+ *
+ */
+public class ColorPickerPanelView extends View {
+
+    /**
+     * The width in pixels of the border
+     * surrounding the color panel.
+     */
+    private final static float    BORDER_WIDTH_PX = 1;
+
+    private float mDensity = 1f;
+
+    private int         mBorderColor = 0xff6E6E6E;
+    private int         mColor = 0xff000000;
+
+    private Paint        mBorderPaint;
+    private Paint        mColorPaint;
+
+    private RectF        mDrawingRect;
+    private RectF        mColorRect;
+
+    private AlphaPatternDrawable mAlphaPattern;
+
+
+    public ColorPickerPanelView(Context context){
+        this(context, null);
+    }
+
+    public ColorPickerPanelView(Context context, AttributeSet attrs){
+        this(context, attrs, 0);
+    }
+
+    public ColorPickerPanelView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        init();
+    }
+
+    private void init(){
+        mBorderPaint = new Paint();
+        mColorPaint = new Paint();
+        mDensity = getContext().getResources().getDisplayMetrics().density;
+    }
+
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+
+        final RectF    rect = mColorRect;
+
+        if(BORDER_WIDTH_PX > 0){
+            mBorderPaint.setColor(mBorderColor);
+            canvas.drawRect(mDrawingRect, mBorderPaint);
+        }
+
+        if(mAlphaPattern != null){
+            mAlphaPattern.draw(canvas);
+        }
+
+        mColorPaint.setColor(mColor);
+
+        canvas.drawRect(rect, mColorPaint);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+
+        int width = MeasureSpec.getSize(widthMeasureSpec);
+        int height = MeasureSpec.getSize(heightMeasureSpec);
+
+        setMeasuredDimension(width, height);
+    }
+
+    @Override
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+        super.onSizeChanged(w, h, oldw, oldh);
+
+        mDrawingRect = new RectF();
+        mDrawingRect.left =  getPaddingLeft();
+        mDrawingRect.right  = w - getPaddingRight();
+        mDrawingRect.top = getPaddingTop();
+        mDrawingRect.bottom = h - getPaddingBottom();
+
+        setUpColorRect();
+
+    }
+
+    private void setUpColorRect(){
+        final RectF    dRect = mDrawingRect;
+
+        float left = dRect.left + BORDER_WIDTH_PX;
+        float top = dRect.top + BORDER_WIDTH_PX;
+        float bottom = dRect.bottom - BORDER_WIDTH_PX;
+        float right = dRect.right - BORDER_WIDTH_PX;
+
+        mColorRect = new RectF(left,top, right, bottom);
+
+        mAlphaPattern = new AlphaPatternDrawable((int)(5 * mDensity));
+
+        mAlphaPattern.setBounds(
+            Math.round(mColorRect.left),
+            Math.round(mColorRect.top),
+            Math.round(mColorRect.right),
+            Math.round(mColorRect.bottom)
+        );
+
+    }
+
+    /**
+     * Set the color that should be shown by this view.
+     * @param color
+     */
+    public void setColor(int color){
+        mColor = color;
+        invalidate();
+    }
+
+    /**
+     * Get the color currently show by this view.
+     * @return
+     */
+    public int getColor(){
+        return mColor;
+    }
+
+    /**
+     * Set the color of the border surrounding the panel.
+     * @param color
+     */
+    public void setBorderColor(int color){
+        mBorderColor = color;
+        invalidate();
+    }
+
+    /**
+     * Get the color of the border surrounding the panel.
+     */
+    public int getBorderColor(){
+        return mBorderColor;
+    }
+
+}
diff --git a/src/net/margaritov/preference/colorpicker/ColorPickerPreference.java b/src/net/margaritov/preference/colorpicker/ColorPickerPreference.java
new file mode 100644
index 0000000..4df3dd6
--- /dev/null
+++ b/src/net/margaritov/preference/colorpicker/ColorPickerPreference.java
@@ -0,0 +1,286 @@
+/*
+ * Copyright (C) 2011 Sergey Margaritov
+ * Copyright (C) 2013 Slimroms
+ * Copyright (C) 2015 DarkKat
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.margaritov.preference.colorpicker;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.graphics.Color;
+import android.preference.Preference;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.view.View;
+import android.widget.EditText;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+
+import com.android.settings.R;
+
+/**
+ * A preference type that allows a user to choose a time
+ * 
+ * @author Sergey Margaritov
+ */
+public class ColorPickerPreference extends Preference implements
+        Preference.OnPreferenceClickListener, ColorPickerDialog.OnColorChangedListener {
+
+    View mView;
+    LinearLayout widgetFrameView;
+    int mDefaultValue = Color.BLACK;
+    int mAndroidColor = 0x00000000;
+    int mBlissColor = mAndroidColor;
+    private int mValue = Color.BLACK;
+    private float mDensity = 0;
+    private boolean mAlphaSliderEnabled = true;
+
+    private static final String androidns = "http://schemas.android.com/apk/res/android";
+
+    private EditText mEditText;
+
+    public ColorPickerPreference(Context context) {
+        super(context);
+        init(context, null);
+    }
+
+    public ColorPickerPreference(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init(context, attrs);
+    }
+
+    public ColorPickerPreference(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        init(context, attrs);
+    }
+
+    @Override
+    protected void onSetInitialValue(boolean restoreValue, Object defaultValue) {
+        onColorChanged(restoreValue ? getValue() : (Integer) defaultValue);
+    }
+
+    private void init(Context context, AttributeSet attrs) {
+        mDensity = getContext().getResources().getDisplayMetrics().density;
+        setOnPreferenceClickListener(this);
+        if (attrs != null) {
+            String defaultValue = attrs.getAttributeValue(androidns, "defaultValue");
+            if (defaultValue.startsWith("#")) {
+                try {
+                    mDefaultValue = convertToColorInt(defaultValue);
+                } catch (NumberFormatException e) {
+                    Log.e("ColorPickerPreference", "Wrong color: " + defaultValue);
+                    mDefaultValue = convertToColorInt("#FF000000");
+                }
+            } else {
+                int resourceId = attrs.getAttributeResourceValue(androidns, "defaultValue", 0);
+                if (resourceId != 0) {
+                    mDefaultValue = context.getResources().getInteger(resourceId);
+                }
+            }
+            mAlphaSliderEnabled = attrs.getAttributeBooleanValue(null, "alphaSlider", true);
+        }
+        mValue = mDefaultValue;
+    }
+
+    @Override
+    protected void onBindView(View view) {
+        mView = view;
+        super.onBindView(view);
+
+        widgetFrameView = ((LinearLayout) view
+                .findViewById(android.R.id.widget_frame));
+
+        setPreviewColor();
+    }
+
+    private void setPreviewColor() {
+        if (mView == null)
+            return;
+
+        ImageView iView = new ImageView(getContext());
+        LinearLayout widgetFrameView = ((LinearLayout) mView
+                .findViewById(android.R.id.widget_frame));
+        if (widgetFrameView == null)
+            return;
+
+        widgetFrameView.setVisibility(View.VISIBLE);
+        widgetFrameView.setPadding(
+                widgetFrameView.getPaddingLeft(),
+                widgetFrameView.getPaddingTop(),
+                (int) (mDensity * 8),
+                widgetFrameView.getPaddingBottom()
+                );
+        // remove already create preview image
+        int count = widgetFrameView.getChildCount();
+        if (count > 0) {
+            widgetFrameView.removeViews(0, count);
+        }
+        widgetFrameView.addView(iView);
+        widgetFrameView.setMinimumWidth(0);
+        iView.setBackgroundDrawable(new AlphaPatternDrawable((int) (5 * mDensity)));
+        iView.setImageBitmap(getPreviewBitmap());
+    }
+
+    private Bitmap getPreviewBitmap() {
+        int d = (int) (mDensity * 31); // 30dip
+        int color = getValue();
+        Bitmap bm = Bitmap.createBitmap(d, d, Config.ARGB_8888);
+        int w = bm.getWidth();
+        int h = bm.getHeight();
+        int c = color;
+        for (int i = 0; i < w; i++) {
+            for (int j = i; j < h; j++) {
+                c = (i <= 1 || j <= 1 || i >= w - 2 || j >= h - 2) ? Color.GRAY : color;
+                bm.setPixel(i, j, c);
+                if (i != j) {
+                    bm.setPixel(j, i, c);
+                }
+            }
+        }
+
+        return bm;
+    }
+
+    public int getValue() {
+        try {
+            if (isPersistent()) {
+                mValue = getPersistedInt(mDefaultValue);
+            }
+        } catch (ClassCastException e) {
+            mValue = mDefaultValue;
+        }
+
+        return mValue;
+    }
+
+    @Override
+    public void onColorChanged(int color) {
+        if (isPersistent()) {
+            persistInt(color);
+        }
+        mValue = color;
+        setPreviewColor();
+        try {
+            getOnPreferenceChangeListener().onPreferenceChange(this, color);
+        } catch (NullPointerException e) {
+        }
+        try {
+            mEditText.setText(Integer.toString(color, 16));
+        } catch (NullPointerException e) {
+        }
+    }
+
+    public boolean onPreferenceClick(Preference preference) {
+        ColorPickerDialog picker = new ColorPickerDialog(
+                getContext(), R.style.Theme_ColorPickerDialog, getValue(),
+                mAndroidColor, mBlissColor);
+        picker.setOnColorChangedListener(this);
+        if (mAlphaSliderEnabled) {
+            picker.setAlphaSliderVisible(true);
+        }
+        picker.show();
+
+        return false;
+    }
+
+    /**
+     * Toggle Alpha Slider visibility (by default it's disabled)
+     * 
+     * @param enable
+     */
+    public void setAlphaSliderEnabled(boolean enable) {
+        mAlphaSliderEnabled = enable;
+    }
+
+    public void setDefaultColors(int androidColor, int blissColor) {
+        mAndroidColor = androidColor;
+        mBlissColor = blissColor;
+    }
+
+    /**
+     * For custom purposes. Not used by ColorPickerPreferrence
+     *
+     * set color preview value from outside
+     * @author kufikugel
+     */
+    public void setNewPreviewColor(int color) {
+        onColorChanged(color);
+    }
+
+    /**
+     * For custom purposes. Not used by ColorPickerPreferrence
+     * 
+     * @param color
+     * @author Unknown
+     */
+    public static String convertToARGB(int color) {
+        String alpha = Integer.toHexString(Color.alpha(color));
+        String red = Integer.toHexString(Color.red(color));
+        String green = Integer.toHexString(Color.green(color));
+        String blue = Integer.toHexString(Color.blue(color));
+
+        if (alpha.length() == 1) {
+            alpha = "0" + alpha;
+        }
+
+        if (red.length() == 1) {
+            red = "0" + red;
+        }
+
+        if (green.length() == 1) {
+            green = "0" + green;
+        }
+
+        if (blue.length() == 1) {
+            blue = "0" + blue;
+        }
+
+        return "#" + alpha + red + green + blue;
+    }
+
+    /**
+     * For custom purposes. Not used by ColorPickerPreferrence
+     * 
+     * @param argb
+     * @throws NumberFormatException
+     * @author Unknown
+     */
+    public static int convertToColorInt(String argb) throws NumberFormatException {
+
+        if (argb.startsWith("#")) {
+            argb = argb.replace("#", "");
+        }
+
+        int alpha = -1, red = -1, green = -1, blue = -1;
+
+        if (argb.length() == 8) {
+            alpha = Integer.parseInt(argb.substring(0, 2), 16);
+            red = Integer.parseInt(argb.substring(2, 4), 16);
+            green = Integer.parseInt(argb.substring(4, 6), 16);
+            blue = Integer.parseInt(argb.substring(6, 8), 16);
+        }
+        else if (argb.length() == 6) {
+            alpha = 255;
+            red = Integer.parseInt(argb.substring(0, 2), 16);
+            green = Integer.parseInt(argb.substring(2, 4), 16);
+            blue = Integer.parseInt(argb.substring(4, 6), 16);
+        }
+
+        return Color.argb(alpha, red, green, blue);
+    }
+}
+
diff --git a/src/net/margaritov/preference/colorpicker/ColorPickerView.java b/src/net/margaritov/preference/colorpicker/ColorPickerView.java
new file mode 100644
index 0000000..0c165ce
--- /dev/null
+++ b/src/net/margaritov/preference/colorpicker/ColorPickerView.java
@@ -0,0 +1,954 @@
+/*
+ * Copyright (C) 2010 Daniel Nilsson
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.margaritov.preference.colorpicker;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.ComposeShader;
+import android.graphics.LinearGradient;
+import android.graphics.Paint;
+import android.graphics.Paint.Align;
+import android.graphics.Paint.Style;
+import android.graphics.Point;
+import android.graphics.PorterDuff;
+import android.graphics.RectF;
+import android.graphics.Shader;
+import android.graphics.Shader.TileMode;
+import android.util.AttributeSet;
+import android.view.MotionEvent;
+import android.view.View;
+
+/**
+ * Displays a color picker to the user and allow them
+ * to select a color. A slider for the alpha channel is
+ * also available. Enable it by setting
+ * setAlphaSliderVisible(boolean) to true.
+ * @author Daniel Nilsson
+ */
+public class ColorPickerView extends View {
+
+	private final static int	PANEL_SAT_VAL = 0;
+	private final static int	PANEL_HUE = 1;
+	private final static int	PANEL_ALPHA = 2;
+
+	/**
+	 * The width in pixels of the border
+	 * surrounding all color panels.
+	 */
+	private final static float	BORDER_WIDTH_PX = 1;
+
+	/**
+	 * The width in dp of the hue panel.
+	 */
+	private float 		HUE_PANEL_WIDTH = 36f;
+	/**
+	 * The height in dp of the alpha panel
+	 */
+	private float		ALPHA_PANEL_HEIGHT = 36f;
+	/**
+	 * The distance in dp between the different
+	 * color panels.
+	 */
+	private float 		PANEL_SPACING = 8f;
+	/**
+	 * The radius in dp of the color palette tracker circle.
+	 */
+	private float 		PALETTE_CIRCLE_TRACKER_RADIUS = 5f;
+	/**
+	 * The dp which the tracker of the hue or alpha panel
+	 * will extend outside of its bounds.
+	 */
+	private float		RECTANGLE_TRACKER_OFFSET = 3f;
+
+
+	private float 		mDensity = 1f;
+
+	private OnColorChangedListener	mListener;
+
+	private Paint 		mSatValPaint;
+	private Paint		mSatValTrackerPaint;
+
+	private Paint		mHuePaint;
+	private Paint		mHueTrackerPaint;
+
+	private Paint		mAlphaPaint;
+	private Paint		mAlphaTextPaint;
+
+	private Paint		mBorderPaint;
+
+	private Shader		mValShader;
+	private Shader		mSatShader;
+	private Shader		mHueShader;
+	private Shader		mAlphaShader;
+
+	private int			mAlpha = 0xff;
+	private float		mHue = 360f;
+	private float 		mSat = 0f;
+	private float 		mVal = 0f;
+
+	private String		mAlphaSliderText = "";
+	private int 		mSliderTrackerColor = 0xff1c1c1c;
+	private int 		mBorderColor = 0xff6E6E6E;
+	private boolean		mShowAlphaPanel = false;
+
+	/*
+	 * To remember which panel that has the "focus" when
+	 * processing hardware button data.
+	 */
+	private int			mLastTouchedPanel = PANEL_SAT_VAL;
+
+	/**
+	 * Offset from the edge we must have or else
+	 * the finger tracker will get clipped when
+	 * it is drawn outside of the view.
+	 */
+	private float 		mDrawingOffset;
+
+
+	/*
+	 * Distance form the edges of the view
+	 * of where we are allowed to draw.
+	 */
+	private RectF	mDrawingRect;
+
+	private RectF	mSatValRect;
+	private RectF 	mHueRect;
+	private RectF	mAlphaRect;
+
+	private AlphaPatternDrawable	mAlphaPattern;
+
+	private Point	mStartTouchPoint = null;
+
+	public interface OnColorChangedListener {
+		public void onColorChanged(int color);
+	}
+
+	public ColorPickerView(Context context){
+		this(context, null);
+	}
+
+	public ColorPickerView(Context context, AttributeSet attrs) {
+		this(context, attrs, 0);
+	}
+
+	public ColorPickerView(Context context, AttributeSet attrs, int defStyle) {
+		super(context, attrs, defStyle);
+		init();
+	}
+
+	private void init(){
+        setLayerType(View.LAYER_TYPE_SOFTWARE, null);
+		mDensity = getContext().getResources().getDisplayMetrics().density;
+		PALETTE_CIRCLE_TRACKER_RADIUS *= mDensity;
+		RECTANGLE_TRACKER_OFFSET *= mDensity;
+		HUE_PANEL_WIDTH *= mDensity;
+		ALPHA_PANEL_HEIGHT *= mDensity;
+		PANEL_SPACING = PANEL_SPACING * mDensity;
+
+		mDrawingOffset = calculateRequiredOffset();
+
+		initPaintTools();
+
+		//Needed for receiving trackball motion events.
+		setFocusable(true);
+		setFocusableInTouchMode(true);
+	}
+
+	private void initPaintTools(){
+
+		mSatValPaint = new Paint();
+		mSatValTrackerPaint = new Paint();
+		mHuePaint = new Paint();
+		mHueTrackerPaint = new Paint();
+		mAlphaPaint = new Paint();
+		mAlphaTextPaint = new Paint();
+		mBorderPaint = new Paint();
+
+
+		mSatValTrackerPaint.setStyle(Style.STROKE);
+		mSatValTrackerPaint.setStrokeWidth(2f * mDensity);
+		mSatValTrackerPaint.setAntiAlias(true);
+
+		mHueTrackerPaint.setColor(mSliderTrackerColor);
+		mHueTrackerPaint.setStyle(Style.STROKE);
+		mHueTrackerPaint.setStrokeWidth(2f * mDensity);
+		mHueTrackerPaint.setAntiAlias(true);
+
+		mAlphaTextPaint.setColor(0xff1c1c1c);
+		mAlphaTextPaint.setTextSize(14f * mDensity);
+		mAlphaTextPaint.setAntiAlias(true);
+		mAlphaTextPaint.setTextAlign(Align.CENTER);
+		mAlphaTextPaint.setFakeBoldText(true);
+
+
+	}
+
+	private float calculateRequiredOffset(){
+		float offset = Math.max(PALETTE_CIRCLE_TRACKER_RADIUS, RECTANGLE_TRACKER_OFFSET);
+		offset = Math.max(offset, BORDER_WIDTH_PX * mDensity);
+
+		return offset * 1.5f;
+	}
+
+	private int[] buildHueColorArray(){
+
+		int[] hue = new int[361];
+
+		int count = 0;
+		for(int i = hue.length -1; i >= 0; i--, count++){
+			hue[count] = Color.HSVToColor(new float[]{i, 1f, 1f});
+		}
+
+		return hue;
+	}
+
+
+	@Override
+	protected void onDraw(Canvas canvas) {
+
+		if(mDrawingRect.width() <= 0 || mDrawingRect.height() <= 0) return;
+
+		drawSatValPanel(canvas);
+		drawHuePanel(canvas);
+		drawAlphaPanel(canvas);
+
+	}
+
+	private void drawSatValPanel(Canvas canvas){
+
+		final RectF	rect = mSatValRect;
+
+		if(BORDER_WIDTH_PX > 0){
+			mBorderPaint.setColor(mBorderColor);
+			canvas.drawRect(mDrawingRect.left, mDrawingRect.top, rect.right + BORDER_WIDTH_PX, rect.bottom + BORDER_WIDTH_PX, mBorderPaint);
+		}
+
+		if (mValShader == null) {
+			mValShader = new LinearGradient(rect.left, rect.top, rect.left, rect.bottom,
+					0xffffffff, 0xff000000, TileMode.CLAMP);
+		}
+
+		int rgb = Color.HSVToColor(new float[]{mHue,1f,1f});
+
+		mSatShader = new LinearGradient(rect.left, rect.top, rect.right, rect.top,
+				0xffffffff, rgb, TileMode.CLAMP);
+		ComposeShader mShader = new ComposeShader(mValShader, mSatShader, PorterDuff.Mode.MULTIPLY);
+		mSatValPaint.setShader(mShader);
+
+		canvas.drawRect(rect, mSatValPaint);
+
+		Point p = satValToPoint(mSat, mVal);
+
+		mSatValTrackerPaint.setColor(0xff000000);
+		canvas.drawCircle(p.x, p.y, PALETTE_CIRCLE_TRACKER_RADIUS - 1f * mDensity, mSatValTrackerPaint);
+
+		mSatValTrackerPaint.setColor(0xffdddddd);
+		canvas.drawCircle(p.x, p.y, PALETTE_CIRCLE_TRACKER_RADIUS, mSatValTrackerPaint);
+
+	}
+
+	private void drawHuePanel(Canvas canvas){
+
+		final RectF rect = mHueRect;
+
+		if(BORDER_WIDTH_PX > 0){
+			mBorderPaint.setColor(mBorderColor);
+			canvas.drawRect(rect.left - BORDER_WIDTH_PX,
+					rect.top - BORDER_WIDTH_PX,
+					rect.right + BORDER_WIDTH_PX,
+					rect.bottom + BORDER_WIDTH_PX,
+					mBorderPaint);
+		}
+
+		if (mHueShader == null) {
+			mHueShader = new LinearGradient(rect.left, rect.top, rect.left, rect.bottom, buildHueColorArray(), null, TileMode.CLAMP);
+			mHuePaint.setShader(mHueShader);
+		}
+
+		canvas.drawRect(rect, mHuePaint);
+
+		float rectHeight = 4 * mDensity / 2;
+
+		Point p = hueToPoint(mHue);
+
+		RectF r = new RectF();
+		r.left = rect.left - RECTANGLE_TRACKER_OFFSET;
+		r.right = rect.right + RECTANGLE_TRACKER_OFFSET;
+		r.top = p.y - rectHeight;
+		r.bottom = p.y + rectHeight;
+
+
+		canvas.drawRoundRect(r, 2, 2, mHueTrackerPaint);
+
+	}
+
+	private void drawAlphaPanel(Canvas canvas){
+
+		if(!mShowAlphaPanel || mAlphaRect == null || mAlphaPattern == null) return;
+
+		final RectF rect = mAlphaRect;
+
+		if(BORDER_WIDTH_PX > 0){
+			mBorderPaint.setColor(mBorderColor);
+			canvas.drawRect(rect.left - BORDER_WIDTH_PX,
+					rect.top - BORDER_WIDTH_PX,
+					rect.right + BORDER_WIDTH_PX,
+					rect.bottom + BORDER_WIDTH_PX,
+					mBorderPaint);
+		}
+
+
+		mAlphaPattern.draw(canvas);
+
+		float[] hsv = new float[]{mHue,mSat,mVal};
+		int color = Color.HSVToColor(hsv);
+		int acolor = Color.HSVToColor(0, hsv);
+
+		mAlphaShader = new LinearGradient(rect.left, rect.top, rect.right, rect.top,
+				color, acolor, TileMode.CLAMP);
+
+
+		mAlphaPaint.setShader(mAlphaShader);
+
+		canvas.drawRect(rect, mAlphaPaint);
+
+		if(mAlphaSliderText != null && mAlphaSliderText!= ""){
+			canvas.drawText(mAlphaSliderText, rect.centerX(), rect.centerY() + 4 * mDensity, mAlphaTextPaint);
+		}
+
+		float rectWidth = 4 * mDensity / 2;
+
+		Point p = alphaToPoint(mAlpha);
+
+		RectF r = new RectF();
+		r.left = p.x - rectWidth;
+		r.right = p.x + rectWidth;
+		r.top = rect.top - RECTANGLE_TRACKER_OFFSET;
+		r.bottom = rect.bottom + RECTANGLE_TRACKER_OFFSET;
+
+		canvas.drawRoundRect(r, 2, 2, mHueTrackerPaint);
+
+	}
+
+
+	private Point hueToPoint(float hue){
+
+		final RectF rect = mHueRect;
+		final float height = rect.height();
+
+		Point p = new Point();
+
+		p.y = (int) (height - (hue * height / 360f) + rect.top);
+		p.x = (int) rect.left;
+
+		return p;
+	}
+
+	private Point satValToPoint(float sat, float val){
+
+		final RectF rect = mSatValRect;
+		final float height = rect.height();
+		final float width = rect.width();
+
+		Point p = new Point();
+
+		p.x = (int) (sat * width + rect.left);
+		p.y = (int) ((1f - val) * height + rect.top);
+
+		return p;
+	}
+
+	private Point alphaToPoint(int alpha){
+
+		final RectF rect = mAlphaRect;
+		final float width = rect.width();
+
+		Point p = new Point();
+
+		p.x = (int) (width - (alpha * width / 0xff) + rect.left);
+		p.y = (int) rect.top;
+
+		return p;
+
+	}
+
+	private float[] pointToSatVal(float x, float y){
+
+		final RectF rect = mSatValRect;
+		float[] result = new float[2];
+
+		float width = rect.width();
+		float height = rect.height();
+
+		if (x < rect.left){
+			x = 0f;
+		}
+		else if(x > rect.right){
+			x = width;
+		}
+		else{
+			x = x - rect.left;
+		}
+
+		if (y < rect.top){
+			y = 0f;
+		}
+		else if(y > rect.bottom){
+			y = height;
+		}
+		else{
+			y = y - rect.top;
+		}
+
+
+		result[0] = 1.f / width * x;
+		result[1] = 1.f - (1.f / height * y);
+
+		return result;
+	}
+
+	private float pointToHue(float y){
+
+		final RectF rect = mHueRect;
+
+		float height = rect.height();
+
+		if (y < rect.top){
+			y = 0f;
+		}
+		else if(y > rect.bottom){
+			y = height;
+		}
+		else{
+			y = y - rect.top;
+		}
+
+		return 360f - (y * 360f / height);
+	}
+
+	private int pointToAlpha(int x){
+
+		final RectF rect = mAlphaRect;
+		final int width = (int) rect.width();
+
+		if(x < rect.left){
+			x = 0;
+		}
+		else if(x > rect.right){
+			x = width;
+		}
+		else{
+			x = x - (int)rect.left;
+		}
+
+		return 0xff - (x * 0xff / width);
+
+	}
+
+
+	@Override
+	public boolean onTrackballEvent(MotionEvent event) {
+
+		float x = event.getX();
+		float y = event.getY();
+
+		boolean update = false;
+
+
+		if(event.getAction() == MotionEvent.ACTION_MOVE){
+
+			switch(mLastTouchedPanel){
+
+			case PANEL_SAT_VAL:
+
+				float sat, val;
+
+				sat = mSat + x/50f;
+				val = mVal - y/50f;
+
+				if(sat < 0f){
+					sat = 0f;
+				}
+				else if(sat > 1f){
+					sat = 1f;
+				}
+
+				if(val < 0f){
+					val = 0f;
+				}
+				else if(val > 1f){
+					val = 1f;
+				}
+
+				mSat = sat;
+				mVal = val;
+
+				update = true;
+
+				break;
+
+			case PANEL_HUE:
+
+				float hue = mHue - y * 10f;
+
+				if(hue < 0f){
+					hue = 0f;
+				}
+				else if(hue > 360f){
+					hue = 360f;
+				}
+
+				mHue = hue;
+
+				update = true;
+
+				break;
+
+			case PANEL_ALPHA:
+
+				if(!mShowAlphaPanel || mAlphaRect == null){
+					update = false;
+				}
+				else{
+
+					int alpha = (int) (mAlpha - x*10);
+
+					if(alpha < 0){
+						alpha = 0;
+					}
+					else if(alpha > 0xff){
+						alpha = 0xff;
+					}
+
+					mAlpha = alpha;
+
+
+					update = true;
+				}
+
+				break;
+			}
+
+
+		}
+
+
+		if(update){
+
+			if(mListener != null){
+				mListener.onColorChanged(Color.HSVToColor(mAlpha, new float[]{mHue, mSat, mVal}));
+			}
+
+			invalidate();
+			return true;
+		}
+
+
+		return super.onTrackballEvent(event);
+	}
+
+	@Override
+	public boolean onTouchEvent(MotionEvent event) {
+
+		boolean update = false;
+
+		switch(event.getAction()){
+
+		case MotionEvent.ACTION_DOWN:
+
+			mStartTouchPoint = new Point((int)event.getX(), (int)event.getY());
+
+			update = moveTrackersIfNeeded(event);
+
+			break;
+
+		case MotionEvent.ACTION_MOVE:
+
+			update = moveTrackersIfNeeded(event);
+
+			break;
+
+		case MotionEvent.ACTION_UP:
+
+			mStartTouchPoint = null;
+
+			update = moveTrackersIfNeeded(event);
+
+			break;
+
+		}
+
+		if(update){
+
+			if(mListener != null){
+				mListener.onColorChanged(Color.HSVToColor(mAlpha, new float[]{mHue, mSat, mVal}));
+			}
+
+			invalidate();
+			return true;
+		}
+
+
+		return super.onTouchEvent(event);
+	}
+
+	private boolean moveTrackersIfNeeded(MotionEvent event){
+
+		if(mStartTouchPoint == null) return false;
+
+		boolean update = false;
+
+		int startX = mStartTouchPoint.x;
+		int startY = mStartTouchPoint.y;
+
+
+		if(mHueRect.contains(startX, startY)){
+			mLastTouchedPanel = PANEL_HUE;
+
+			mHue = pointToHue(event.getY());
+
+			update = true;
+		}
+		else if(mSatValRect.contains(startX, startY)){
+
+			mLastTouchedPanel = PANEL_SAT_VAL;
+
+			float[] result = pointToSatVal(event.getX(), event.getY());
+
+			mSat = result[0];
+			mVal = result[1];
+
+			update = true;
+		}
+		else if(mAlphaRect != null && mAlphaRect.contains(startX, startY)){
+
+			mLastTouchedPanel = PANEL_ALPHA;
+
+			mAlpha = pointToAlpha((int)event.getX());
+
+			update = true;
+		}
+
+
+		return update;
+	}
+
+	@Override
+	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+
+		int width = 0;
+		int height = 0;
+		
+		int widthMode = MeasureSpec.getMode(widthMeasureSpec);
+		int heightMode = MeasureSpec.getMode(heightMeasureSpec);
+		
+		int widthAllowed = MeasureSpec.getSize(widthMeasureSpec);
+		int heightAllowed = MeasureSpec.getSize(heightMeasureSpec);
+		
+		widthAllowed = chooseWidth(widthMode, widthAllowed);
+		heightAllowed = chooseHeight(heightMode, heightAllowed);
+		
+		if(!mShowAlphaPanel){
+			
+			height = (int) (widthAllowed - PANEL_SPACING - HUE_PANEL_WIDTH);
+
+			//If calculated height (based on the width) is more than the allowed height.
+			if(height > heightAllowed || "landscape".equals(getTag())) {
+				height = heightAllowed;
+				width = (int) (height + PANEL_SPACING + HUE_PANEL_WIDTH);
+			}
+			else{
+				width = widthAllowed;
+			}
+		}
+		else{
+
+			width = (int) (heightAllowed - ALPHA_PANEL_HEIGHT + HUE_PANEL_WIDTH);
+
+			if(width > widthAllowed){
+				width = widthAllowed;
+				height = (int) (widthAllowed - HUE_PANEL_WIDTH + ALPHA_PANEL_HEIGHT);
+			}
+			else{
+				height = heightAllowed;
+			}
+
+		}
+		
+		setMeasuredDimension(width, height);
+	}
+
+	private int chooseWidth(int mode, int size){
+		if (mode == MeasureSpec.AT_MOST || mode == MeasureSpec.EXACTLY) {
+			return size;
+		} else { // (mode == MeasureSpec.UNSPECIFIED)
+			return getPrefferedWidth();
+		}
+	}
+
+	private int chooseHeight(int mode, int size){
+		if (mode == MeasureSpec.AT_MOST || mode == MeasureSpec.EXACTLY) {
+			return size;
+		} else { // (mode == MeasureSpec.UNSPECIFIED)
+			return getPrefferedHeight();
+		}
+	}
+
+	private int getPrefferedWidth(){
+
+		int width = getPrefferedHeight();
+
+		if(mShowAlphaPanel){
+			width -= (PANEL_SPACING + ALPHA_PANEL_HEIGHT);
+		}
+
+
+		return (int) (width + HUE_PANEL_WIDTH + PANEL_SPACING);
+
+	}
+
+	private int getPrefferedHeight(){
+
+		int height = (int)(200 * mDensity);
+
+		if(mShowAlphaPanel){
+			height += PANEL_SPACING + ALPHA_PANEL_HEIGHT;
+		}
+
+		return height;
+	}
+
+
+
+	@Override
+	protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+		super.onSizeChanged(w, h, oldw, oldh);
+
+		mDrawingRect = new RectF();
+		mDrawingRect.left = mDrawingOffset + getPaddingLeft();
+		mDrawingRect.right  = w - mDrawingOffset - getPaddingRight();
+		mDrawingRect.top = mDrawingOffset + getPaddingTop();
+		mDrawingRect.bottom = h - mDrawingOffset - getPaddingBottom();
+
+		setUpSatValRect();
+		setUpHueRect();
+		setUpAlphaRect();
+	}
+
+	private void setUpSatValRect(){
+
+		final RectF	dRect = mDrawingRect;
+		float panelSide = dRect.height() - BORDER_WIDTH_PX * 2;
+
+		if(mShowAlphaPanel){
+			panelSide -= PANEL_SPACING + ALPHA_PANEL_HEIGHT;
+		}
+
+		float left = dRect.left + BORDER_WIDTH_PX;
+		float top = dRect.top + BORDER_WIDTH_PX;
+		float bottom = top + panelSide;
+		float right = left + panelSide;
+
+		mSatValRect = new RectF(left,top, right, bottom);
+	}
+
+	private void setUpHueRect(){
+		final RectF	dRect = mDrawingRect;
+
+		float left = dRect.right - HUE_PANEL_WIDTH + BORDER_WIDTH_PX;
+		float top = dRect.top + BORDER_WIDTH_PX;
+		float bottom = dRect.bottom - BORDER_WIDTH_PX - (mShowAlphaPanel ? (PANEL_SPACING + ALPHA_PANEL_HEIGHT) : 0);
+		float right = dRect.right - BORDER_WIDTH_PX;
+
+		mHueRect = new RectF(left, top, right, bottom);
+	}
+
+	private void setUpAlphaRect() {
+
+		if(!mShowAlphaPanel) return;
+
+		final RectF	dRect = mDrawingRect;
+
+		float left = dRect.left + BORDER_WIDTH_PX;
+		float top = dRect.bottom - ALPHA_PANEL_HEIGHT + BORDER_WIDTH_PX;
+		float bottom = dRect.bottom - BORDER_WIDTH_PX;
+		float right = dRect.right - BORDER_WIDTH_PX;
+
+		mAlphaRect = new RectF(left, top, right, bottom);
+
+		mAlphaPattern = new AlphaPatternDrawable((int) (5 * mDensity));
+		mAlphaPattern.setBounds(
+			Math.round(mAlphaRect.left), 
+			Math.round(mAlphaRect.top), 
+			Math.round(mAlphaRect.right), 
+			Math.round(mAlphaRect.bottom)
+		);
+
+	}
+
+
+	/**
+	 * Set a OnColorChangedListener to get notified when the color
+	 * selected by the user has changed.
+	 * @param listener
+	 */
+	public void setOnColorChangedListener(OnColorChangedListener listener){
+		mListener = listener;
+	}
+
+	/**
+	 * Set the color of the border surrounding all panels.
+	 * @param color
+	 */
+	public void setBorderColor(int color){
+		mBorderColor = color;
+		invalidate();
+	}
+
+	/**
+	 * Get the color of the border surrounding all panels.
+	 */
+	public int getBorderColor(){
+		return mBorderColor;
+	}
+
+	/**
+	 * Get the current color this view is showing.
+	 * @return the current color.
+	 */
+	public int getColor(){
+		return Color.HSVToColor(mAlpha, new float[]{mHue,mSat,mVal});
+	}
+
+	/**
+	 * Set the color the view should show.
+	 * @param color The color that should be selected.
+	 */
+	public void setColor(int color){
+		setColor(color, false);
+	}
+
+	/**
+	 * Set the color this view should show.
+	 * @param color The color that should be selected.
+	 * @param callback If you want to get a callback to
+	 * your OnColorChangedListener.
+	 */
+	public void setColor(int color, boolean callback){
+
+		int alpha = Color.alpha(color);
+		int red = Color.red(color);
+		int blue = Color.blue(color);
+		int green = Color.green(color);
+
+		float[] hsv = new float[3];
+
+		Color.RGBToHSV(red, green, blue, hsv);
+
+		mAlpha = alpha;
+		mHue = hsv[0];
+		mSat = hsv[1];
+		mVal = hsv[2];
+
+		if(callback && mListener != null){
+			mListener.onColorChanged(Color.HSVToColor(mAlpha, new float[]{mHue, mSat, mVal}));
+		}
+
+		invalidate();
+	}
+
+	/**
+	 * Get the drawing offset of the color picker view.
+	 * The drawing offset is the distance from the side of
+	 * a panel to the side of the view minus the padding.
+	 * Useful if you want to have your own panel below showing
+	 * the currently selected color and want to align it perfectly.
+	 * @return The offset in pixels.
+	 */
+	public float getDrawingOffset(){
+		return mDrawingOffset;
+	}
+
+	/**
+	 * Set if the user is allowed to adjust the alpha panel. Default is false.
+	 * If it is set to false no alpha will be set.
+	 * @param visible
+	 */
+	public void setAlphaSliderVisible(boolean visible){
+
+		if(mShowAlphaPanel != visible){
+			mShowAlphaPanel = visible;
+
+			/*
+			 * Reset all shader to force a recreation.
+			 * Otherwise they will not look right after
+			 * the size of the view has changed.
+			 */
+			mValShader = null;
+			mSatShader = null;
+			mHueShader = null;
+			mAlphaShader = null;;
+
+			requestLayout();
+		}
+
+	}
+
+	public void setSliderTrackerColor(int color){
+		mSliderTrackerColor = color;
+
+		mHueTrackerPaint.setColor(mSliderTrackerColor);
+
+		invalidate();
+	}
+
+	public int getSliderTrackerColor(){
+		return mSliderTrackerColor;
+	}
+
+	/**
+	 * Set the text that should be shown in the
+	 * alpha slider. Set to null to disable text.
+	 * @param res string resource id.
+	 */
+	public void setAlphaSliderText(int res){
+		String text = getContext().getString(res);
+		setAlphaSliderText(text);
+	}
+
+	/**
+	 * Set the text that should be shown in the
+	 * alpha slider. Set to null to disable text.
+	 * @param text Text that should be shown.
+	 */
+	public void setAlphaSliderText(String text){
+		mAlphaSliderText = text;
+		invalidate();
+	}
+
+	/**
+	 * Get the current value of the text
+	 * that will be shown in the alpha
+	 * slider.
+	 * @return
+	 */
+	public String getAlphaSliderText(){
+		return mAlphaSliderText;
+	}
+}
+
